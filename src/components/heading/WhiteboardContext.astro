---
type Props = {
  drawing?: boolean;
};

const { drawing } = Astro.props;
---

<my-whiteboard data-drawing={drawing} class="group">
  <slot />
</my-whiteboard>

<script>
  import { gsap } from "gsap";
  import { attr, controller, target, targets } from "@github/catalyst";
  import { fisherYatesShuffle } from "../../utils.client";
  import MotionPathPlugin from "gsap/MotionPathPlugin";
  import { setUpCanvas } from "./canvas";

  gsap.registerPlugin(MotionPathPlugin);

  const xPoolInitial = [-30, -15, 0, 15, 30];
  const yPoolInitial = [-80, -40, 0, 40, 80, 120];

  @controller
  class MyWhiteboardElement extends HTMLElement {
    @target face: SVGElement;
    @target scribble: SVGPathElement;
    @target eraser: SVGElement;
    @target drawBtn: HTMLButtonElement | undefined;
    @targets eyes: SVGElement[];
    @target canvas: HTMLCanvasElement;

    @attr drawing = false;

    #xPool = fisherYatesShuffle(xPoolInitial);
    #yPool = fisherYatesShuffle(yPoolInitial);
    #xIdx = 0;
    #yIdx = 0;

    #faceAnim?: gsap.core.Tween;
    #eyesAnim?: gsap.core.Timeline;

    scrollToVideos(e: MouseEvent) {
      e.preventDefault();
      document
        .querySelector((e.currentTarget as HTMLAnchorElement).hash)
        ?.scrollIntoView({ behavior: "smooth" });
    }

    startDrawing() {
      if (this.drawing) return;
      this.eraserAnimation();
    }

    async eraserAnimation() {
      this.drawing = true;
      if (this.drawBtn) {
        this.drawBtn.disabled = this.drawing;
      }
      const offset = 1600;
      this.#faceAnim?.pause();
      this.#eyesAnim?.pause();

      const mdBreakpoint = window.matchMedia("(max-width: 768px)");
      if (mdBreakpoint.matches) {
        await new Promise((resolve) => setTimeout(() => resolve(null), 300));
      }

      const eraserRect = this.eraser.getBoundingClientRect();
      const scribbleRect = this.face.getBoundingClientRect();

      const eraseTl = gsap.timeline().to(this.eraser, {
        x: -eraserRect.left + scribbleRect.left - 16,
        y: -eraserRect.top + scribbleRect.top - 40,
        ease: "elastic.out(1,1)",
        duration: 0.4,
      });
      for (let i = 1; i <= 6; i++) {
        eraseTl.to(this.eraser, {
          duration: 0.16,
          delay: i === 1 ? -0.1 : 0,
          ease: "power2.out",
          motionPath: {
            // Different offset to account for stroke width
            offsetX: -eraserRect.left + scribbleRect.left - 38,
            offsetY: -eraserRect.top + scribbleRect.top - 70,
            path: this.scribble,
            start: (i - 1) / 6,
            end: i / 6,
          },
        });
        eraseTl.to(
          this.scribble,
          {
            ease: "power2.out",
            duration: 0.16,
            strokeDashoffset: offset - (offset * i) / 6,
          },
          "<"
        );
      }
      eraseTl.to(this.eraser, {
        x: 0,
        y: 0,
        ease: "elastic.out(1,1)",
        duration: 0.4,
        onStart: () => {
          setUpCanvas(this, this.canvas);
        },
      });
    }

    connectedCallback() {
      if (this.drawing) {
        this.eraserAnimation();
      }

      this.#faceAnim = gsap.to(this.face, {
        x: () => {
          const next = this.#xPool[this.#xIdx];
          this.#xIdx = (this.#xIdx + 1) % this.#xPool.length;
          return next!;
        },
        y: () => {
          const next = this.#yPool[this.#yIdx];
          this.#yIdx = (this.#yIdx + 1) % this.#yPool.length;
          return next!;
        },
        repeatRefresh: true,
        repeat: -1,
        repeatDelay: 4,
        duration: 1,
        delay: 4,
        ease: "elastic.out(1, 0.5)",
      });

      this.#eyesAnim = gsap
        .timeline()
        .set(this.eyes, { transformOrigin: "center bottom" })
        .to(this.eyes, { scaleY: 0.2, duration: 0.2 })
        .to(this.eyes, { scaleY: 1, duration: 0.2 })
        .repeatDelay(3)
        .delay(2)
        .repeat(-1);
    }
  }
</script>
